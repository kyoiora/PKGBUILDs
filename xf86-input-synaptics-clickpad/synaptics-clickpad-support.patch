## This is a collection of the clickpad patches from OpenSUSE


#### xf86-input-synaptics-add-clickpad-support.diff
From 40041cd6ece0a73ac2c4ab99c14a79500089dd64 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 13 Apr 2010 17:25:23 +0200
Subject: [PATCH 1/7] Add Clickpad support

This patch adds the support for Synaptics Clickpad devices.
It requires the change in Linux kernel synaptics input driver, found in
	https://patchwork.kernel.org/patch/92435/
The kernel patch is already included in linux 2.6.34.

When the kernel driver sets only the left-button bit evbit and no
multi-finger is possible, Clickpad mode is activated.  In this mode,
the bottom touch area is used as button emulations.  Clicking at the
bottom-left, bottom-center and bottom-right zone corresponds to a left,
center and right click.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 src/eventcomm.c    |    6 +++++
 src/synaptics.c    |   58 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/synapticsstr.h |    2 +
 3 files changed, 66 insertions(+)

--- a/src/eventcomm.c
+++ b/src/eventcomm.c
@@ -329,6 +329,12 @@
 	strcat(buf, " scroll-buttons");
 
     xf86IDrvMsg(pInfo, X_PROBED, "buttons:%s\n", buf);
+
+    /* clickpad device reports only the single left button mask */
+    if (priv->has_left && !priv->has_right && !priv->has_middle && !priv->has_double) {
+	priv->is_clickpad = TRUE;
+	xf86IDrvMsg(pInfo, X_PROBED, "is Clickpad device\n");
+    }
 }
 
 static Bool
--- a/src/synaptics.c
+++ b/src/synaptics.c
@@ -492,6 +492,18 @@
         vertResolution = priv->resy;
     }
 
+    /* Clickpad mode -- bottom area is used as buttons */
+    if (priv->is_clickpad) {
+	int button_bottom;
+	/* Clickpad devices usually the button area at the bottom, and
+	 * its size seems ca. 20% of the touchpad height no matter how
+	 * large the pad is.
+	 */
+	button_bottom = priv->maxy - (abs(priv->maxy - priv->miny) * 20) / 100;
+	if (button_bottom < b && button_bottom >= t)
+	    b = button_bottom;
+    }
+
     /* set the parameters */
     pars->left_edge = xf86SetIntOption(opts, "LeftEdge", l);
     pars->right_edge = xf86SetIntOption(opts, "RightEdge", r);
@@ -500,6 +512,10 @@
 
     pars->area_top_edge = set_percent_option(opts, "AreaTopEdge", height, priv->miny, 0);
     pars->area_bottom_edge = set_percent_option(opts, "AreaBottomEdge", height, priv->miny, 0);
+    /* in clickpad mode, we don't want to sense the button area as default */
+    if (pars->area_bottom_edge == 0 && priv->is_clickpad)
+	pars->area_bottom_edge = b;
+
     pars->area_left_edge = set_percent_option(opts, "AreaLeftEdge", width, priv->minx, 0);
     pars->area_right_edge = set_percent_option(opts, "AreaRightEdge", width, priv->minx, 0);
 
@@ -1074,6 +1090,44 @@
     return Success;
 }
 
+/* clickpad event handling */
+static void
+handle_clickpad(InputInfoPtr pInfo, struct SynapticsHwState *hw)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    SynapticsParameters *para = &priv->synpara;
+
+    if (hw->left) { /* clicked? */
+	if (hw->y > para->bottom_edge) {
+	    /* button area */
+	    int width = priv->maxx - priv->minx;
+	    int left_button_x, right_button_x;
+
+	    /* left and right clickpad button ranges;
+	     * the gap between them is interpreted as a middle-button click
+	     */
+	    left_button_x = width * 2 / 5 + priv->minx;
+	    right_button_x = width * 3 / 5 + priv->minx;
+
+	    /* clickpad reports only one button, and we need
+	     * to fake left/right buttons depending on the touch position
+	     */
+	    hw->left = 0;
+	    if (hw->x < left_button_x)
+		hw->left = 1;
+	    else if (hw->x > right_button_x)
+		hw->right = 1;
+	    else
+		hw->middle = 1;
+	} else {
+	    /* dragging */
+	    hw->left = priv->prev_hw.left;
+	    hw->right = priv->prev_hw.right;
+	    hw->middle = priv->prev_hw.middle;
+	}
+    }
+    priv->prev_hw = *hw;
+}
 
 /*
  * Convert from absolute X/Y coordinates to a coordinate system where
@@ -2338,6 +2392,10 @@
     SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
     SynapticsParameters *para = &priv->synpara;
 
+    /* Clickpad handling for button area */
+    if (priv->is_clickpad)
+	handle_clickpad(pInfo, hw);
+
     /* Treat the first two multi buttons as up/down for now. */
     hw->up |= hw->multi[0];
     hw->down |= hw->multi[1];
--- a/src/synapticsstr.h
+++ b/src/synapticsstr.h
@@ -244,6 +244,8 @@
     Bool has_pressure;			/* device reports pressure */
     Bool has_width;			/* device reports finger width */
     Bool has_scrollbuttons;		/* device has physical scrollbuttons */
+    Bool is_clickpad;			/* is Clickpad device (one-button) */
+    struct SynapticsHwState prev_hw;	/* previous h/w state (for clickpad) */
 
     enum TouchpadModel model;		/* The detected model */
     unsigned short id_vendor;		/* vendor id */



#### xf86-input-synaptics-clickpad-doc-update.diff
From 71d474096f94da71815a1a9713c73d81d7ebf43f Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Fri, 7 May 2010 16:58:35 +0200
Subject: [PATCH 2/7] Add a brief description of Clickpad to man page

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 man/synaptics.man |    9 +++++++++
 1 file changed, 9 insertions(+)

--- a/man/synaptics.man
+++ b/man/synaptics.man
@@ -753,6 +753,15 @@
 Trackstick mode is exited when the finger pressure drops below
 FingerLow or when the finger is moved further than MaxTapMove away
 from the initial position.
+.
+When the input device reports a device with a single left button
+and without multi-fingers, the driver assumes it's a Synaptics
+Clickpad device and handles it in ClickZone mode.  In this mode,
+a left/right/middle button event is generated according to the
+position you click.  When Clickpad is enabled, the touchpad area
+is shrunk as default in 20% and the bottom area is used as the
+click-button area.  The area can be configurable via options or
+properties below.
 
 .SH "DEVICE PROPERTIES"
 Synaptics 1.0 and higher support input device properties if the driver is



#### xf86-input-synaptics-add-led-support.diff
From f8d9dd1c9710f99d3c402517782ae7ba5ef208eb Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Mon, 10 May 2010 18:15:48 +0200
Subject: [PATCH 3/7] Add the embedded LED support

This patch adds the control of the embedded LED on the top-left corner
of new Synaptics devices.  For LED control, it requires the patch to
Linux synaptics input driver,
	https://patchwork.kernel.org/patch/92434/

When a sysfs file /sys/class/leds/psmouse::synaptics exists, the driver
assumes it supports the embeded LED control.

The LED can be controlled via new properties, "Synaptics LED" and
"Synaptics LED Status".

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 include/synaptics-properties.h |    6 ++++++
 man/synaptics.man              |    9 +++++++++
 src/eventcomm.c                |   32 +++++++++++++++++++++++++++++++-
 src/properties.c               |   15 +++++++++++++++
 src/synapticsstr.h             |    2 ++
 src/synproto.h                 |    1 +
 tools/synclient.c              |    1 +
 7 files changed, 65 insertions(+), 1 deletion(-)

--- a/include/synaptics-properties.h
+++ b/include/synaptics-properties.h
@@ -158,4 +158,10 @@
 /* 32 Bit Integer, 2 values, horizontal hysteresis, vertical hysteresis */
 #define SYNAPTICS_PROP_NOISE_CANCELLATION "Synaptics Noise Cancellation"
 
+/* 8 bit (BOOL, read-only), has_led */
+#define SYNAPTICS_PROP_LED "Synaptics LED"
+
+/* 8 bit (BOOL), led_status (on/off) */
+#define SYNAPTICS_PROP_LED_STATUS "Synaptics LED Status"
+
 #endif /* _SYNAPTICS_PROPERTIES_H_ */
--- a/man/synaptics.man
+++ b/man/synaptics.man
@@ -936,6 +936,15 @@
 .BI "Synaptics Pad Resolution"
 32 bit unsigned, 2 values (read-only), vertical, horizontal in units/millimeter.
 
+.TP 7
+.BI "Synaptics LED"
+8 bit (BOOL, read-only), indicating whether the device has an embedded
+LED support or not.
+
+.TP 7
+.BI "Synaptics LED Status"
+8 bit (BOOL), the light status of the embedded LED.
+
 .SH "NOTES"
 Configuration through
 .I InputClass
--- a/src/eventcomm.c
+++ b/src/eventcomm.c
@@ -48,6 +48,8 @@
 #define LONG_BITS (sizeof(long) * 8)
 #define NBITS(x) (((x) + LONG_BITS - 1) / LONG_BITS)
 
+#define SYNAPTICS_LED_SYS_FILE	"/sys/class/leds/psmouse::synaptics/brightness"
+
 /**
  * Protocol-specific data.
  */
@@ -242,6 +244,32 @@
 }
 
 
+static void
+event_query_led(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
+
+    priv->synpara.has_led = !access(SYNAPTICS_LED_SYS_FILE, W_OK);
+}
+
+static void EventUpdateLED(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
+
+    if (priv->synpara.has_led) {
+        char *val = priv->synpara.led_status ? "255" : "0";
+        int fd = open(SYNAPTICS_LED_SYS_FILE, O_WRONLY);
+        int err;
+
+        if (fd < 0)
+            return;
+        err = write(fd, val, strlen(val));
+        close(fd);
+        if (err < 0)
+	    xf86IDrvMsg(pInfo, X_WARNING, "can't write LED value %s\n", val);
+    }
+}
+
 /* Query device for axis ranges */
 static void
 event_query_axis_ranges(InputInfoPtr pInfo)
@@ -508,6 +536,7 @@
 
     if (event_query_is_touchpad(pInfo->fd, (proto_data) ? proto_data->need_grab : TRUE))
 	event_query_axis_ranges(pInfo);
+    event_query_led(pInfo);
     event_query_model(pInfo->fd, &priv->model, &priv->id_vendor, &priv->id_product);
 
     xf86IDrvMsg(pInfo, X_PROBED, "Vendor %#hx Product %#hx\n",
@@ -598,5 +627,6 @@
     EventQueryHardware,
     EventReadHwState,
     EventAutoDevProbe,
-    EventReadDevDimensions
+    EventReadDevDimensions,
+    EventUpdateLED,
 };
--- a/src/properties.c
+++ b/src/properties.c
@@ -94,6 +94,8 @@
 Atom prop_noise_cancellation    = 0;
 Atom prop_product_id            = 0;
 Atom prop_device_node           = 0;
+Atom prop_led                   = 0;
+Atom prop_led_status            = 0;
 
 static Atom
 InitAtom(DeviceIntPtr dev, char *name, int format, int nvalues, int *values)
@@ -296,6 +298,9 @@
     prop_noise_cancellation = InitAtom(pInfo->dev,
             SYNAPTICS_PROP_NOISE_CANCELLATION, 32, 2, values);
 
+    prop_led = InitAtom(pInfo->dev, SYNAPTICS_PROP_LED, 8, 1, &para->has_led);
+    prop_led_status = InitAtom(pInfo->dev, SYNAPTICS_PROP_LED_STATUS, 8, 1, &para->led_status);
+
     /* only init product_id property if we actually know them */
     if (priv->id_vendor || priv->id_product)
     {
@@ -684,6 +689,16 @@
         para->area_right_edge  = area[1];
         para->area_top_edge    = area[2];
         para->area_bottom_edge = area[3];
+    } else if (property == prop_led_status)
+    {
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        if (para->has_led) {
+            para->led_status = *(BOOL*)prop->data;
+            if (priv->proto_ops && priv->proto_ops->UpdateLED)
+                priv->proto_ops->UpdateLED(pInfo);
+        }
     } else if (property == prop_noise_cancellation) {
         INT32 *hyst;
         if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
--- a/src/synapticsstr.h
+++ b/src/synapticsstr.h
@@ -165,6 +165,8 @@
     unsigned int resolution_vert;           /* vertical resolution of touchpad in units/mm */
     int area_left_edge, area_right_edge, area_top_edge, area_bottom_edge; /* area coordinates absolute */
     int hyst_x, hyst_y;                     /* x and y width of hysteresis box */
+    Bool has_led;                           /* has an embedded LED */
+    Bool led_status;                        /* Current status of LED (1=on) */
 } SynapticsParameters;
 
 
--- a/src/synproto.h
+++ b/src/synproto.h
@@ -77,6 +77,7 @@
 			struct CommData *comm, struct SynapticsHwState *hwRet);
     Bool (*AutoDevProbe)(InputInfoPtr pInfo, const char *device);
     void (*ReadDevDimensions)(InputInfoPtr pInfo);
+    void (*UpdateLED)(InputInfoPtr pInfo);
 };
 
 #ifdef BUILD_PS2COMM
--- a/tools/synclient.c
+++ b/tools/synclient.c
@@ -142,6 +142,7 @@
     {"AreaRightEdge",         PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	1},
     {"AreaTopEdge",           PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	2},
     {"AreaBottomEdge",        PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	3},
+    {"LEDStatus",             PT_BOOL,   0, 1,     SYNAPTICS_PROP_LED_STATUS,	8,	0},
     { NULL, 0, 0, 0, 0 }
 };
 



#### xf86-input-synaptics-led-double-tap.diff
From 72867306cc91d02e282c942ca93fa45f03440335 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 15 Jun 2010 16:54:07 +0200
Subject: [PATCH 4/7] Add tap-on-LED feature support

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 include/synaptics-properties.h |    3 +
 man/synaptics.man              |   17 +++++++
 src/properties.c               |   26 +++++++++++
 src/synaptics.c                |   95 ++++++++++++++++++++++++++++++++++++++++-
 src/synapticsstr.h             |    6 ++
 tools/synclient.c              |    1 
 6 files changed, 146 insertions(+), 2 deletions(-)

--- a/include/synaptics-properties.h
+++ b/include/synaptics-properties.h
@@ -164,4 +164,7 @@
 /* 8 bit (BOOL), led_status (on/off) */
 #define SYNAPTICS_PROP_LED_STATUS "Synaptics LED Status"
 
+/* 8 bit (BOOL), double-tap action on LED corner (on/off) */
+#define SYNAPTICS_PROP_LED_DOUBLE_TAP "Synaptics LED Dobule Tap"
+
 #endif /* _SYNAPTICS_PROPERTIES_H_ */
--- a/man/synaptics.man
+++ b/man/synaptics.man
@@ -564,6 +564,19 @@
 A "touch" event happens when the Z value goes above FingerHigh, and an
 "untouch" event happens when the Z value goes below FingerLow.
 .
+.TP
+.BI "Option \*qLEDDoubleTap\*q \*q" boolean \*q
+.
+Enables/disables the touchpad-control by double-tapping on the top-left
+corner LED.
+.
+Some devices have an LED on the top-left corner to indicate the
+touchpad state.  User can double-tap on the LED to toggle the touchpad
+state.  This option controls whether this action is enabled or not.
+The double-tap size is same as specified in MaxDoubleTapTime.
+The default value is ON.
+Property: "Synaptics LED Double Tap"
+.
 .LP
 The MaxDoubleTapTime parameter has the same function as the MaxTapTime
 parameter, but for the second, third, etc tap in a tap sequence.
@@ -945,6 +958,10 @@
 .BI "Synaptics LED Status"
 8 bit (BOOL), the light status of the embedded LED.
 
+.TP 7
+.BI "Synaptics LED Double Tap"
+8 bit (BOOL), enable/disable the double-tap on LED.
+
 .SH "NOTES"
 Configuration through
 .I InputClass
--- a/src/properties.c
+++ b/src/properties.c
@@ -96,6 +96,7 @@
 Atom prop_device_node           = 0;
 Atom prop_led                   = 0;
 Atom prop_led_status            = 0;
+Atom prop_led_double_tap        = 0;
 
 static Atom
 InitAtom(DeviceIntPtr dev, char *name, int format, int nvalues, int *values)
@@ -301,6 +302,8 @@
     prop_led = InitAtom(pInfo->dev, SYNAPTICS_PROP_LED, 8, 1, &para->has_led);
     prop_led_status = InitAtom(pInfo->dev, SYNAPTICS_PROP_LED_STATUS, 8, 1, &para->led_status);
 
+    prop_led_double_tap = InitAtom(pInfo->dev, SYNAPTICS_PROP_LED_DOUBLE_TAP, 8, 1, &para->led_double_tap);
+
     /* only init product_id property if we actually know them */
     if (priv->id_vendor || priv->id_product)
     {
@@ -543,6 +546,19 @@
             return BadValue;
 
         para->touchpad_off = off;
+        if (!checkonly && para->has_led &&
+	    para->led_status != para->touchpad_off) {
+            para->led_status = para->touchpad_off;
+            if (priv->proto_ops && priv->proto_ops->UpdateLED)
+                priv->proto_ops->UpdateLED(pInfo);
+        }
+    } else if (property == prop_led_double_tap)
+    {
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->led_double_tap = *(CARD8*)prop->data;
+
     } else if (property == prop_gestures)
     {
         BOOL *gestures;
@@ -715,3 +731,13 @@
     return Success;
 }
 
+void SynapticsToggleOffProperty(DeviceIntPtr dev, Bool off)
+{
+        uint8_t val;
+
+        if (!prop_off)
+                return;
+        val = off;
+        XIChangeDeviceProperty(dev, prop_off, XA_INTEGER, 8,
+                               PropModeReplace, 1, &val, FALSE);
+}
--- a/src/synaptics.c
+++ b/src/synaptics.c
@@ -135,6 +135,7 @@
 void InitDeviceProperties(InputInfoPtr pInfo);
 int SetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
                 BOOL checkonly);
+void SynapticsToggleOffProperty(DeviceIntPtr dev, Bool off);
 
 const static struct {
     const char *name;
@@ -588,6 +589,7 @@
     pars->tap_and_drag_gesture = xf86SetBoolOption(opts, "TapAndDragGesture", TRUE);
     pars->resolution_horiz = xf86SetIntOption(opts, "HorizResolution", horizResolution);
     pars->resolution_vert = xf86SetIntOption(opts, "VertResolution", vertResolution);
+    pars->led_double_tap = xf86SetBoolOption(opts, "LEDDoubleTap", TRUE);
 
     /* Warn about (and fix) incorrectly configured TopEdge/BottomEdge parameters */
     if (pars->top_edge > pars->bottom_edge) {
@@ -875,6 +877,10 @@
     xf86AddEnabledDevice(pInfo);
     dev->public.on = TRUE;
 
+    /* update LED */
+    if (priv->proto_ops && priv->proto_ops->UpdateLED)
+        priv->proto_ops->UpdateLED(pInfo);
+
     return Success;
 }
 
@@ -1090,6 +1096,74 @@
     return Success;
 }
 
+#define LED_TOGGLE_X_AREA	0.10
+#define LED_TOGGLE_Y_AREA	0.08
+
+static int
+in_led_toggle_area(InputInfoPtr pInfo, struct SynapticsHwState *hw)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
+    int click_led_x, click_led_y;
+
+    click_led_x = (priv->maxx - priv->minx) * LED_TOGGLE_X_AREA + priv->minx;
+    click_led_y = (priv->maxy - priv->miny) * LED_TOGGLE_Y_AREA + priv->miny;
+    return (hw->x < click_led_x && hw->y < click_led_y);
+}
+
+/* clicpad button toggle point:
+ * some devices have a LED at the upper-left corner, and double-tapping it
+ * toggles the touchpad enable/disable
+ */
+static int
+handle_toggle_led(InputInfoPtr pInfo, struct SynapticsHwState *hw, int finger)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
+    SynapticsParameters *para = &priv->synpara;
+    int diff;
+
+    if (finger) {
+        if (!in_led_toggle_area(pInfo, hw)) {
+            /* outside the toggle area */
+            priv->led_touch_state = FALSE;
+            priv->led_tapped = FALSE;
+            return finger;
+        }
+        if (!priv->led_touch_state) {
+            /* touch start */
+            priv->led_touch_millis = hw->millis;
+            priv->led_touch_state = TRUE;
+        }
+        return 0; /* already processed; ignore this finger event */
+    }
+
+    if (!priv->led_touch_state)
+        return finger; /* nothing happened */
+
+    /* touch-released */
+    priv->led_touch_state = FALSE;
+    diff = TIME_DIFF(priv->led_touch_millis + para->tap_time, hw->millis);
+    if (diff < 0) { /* non-tap? */
+	priv->led_tapped = FALSE;
+        return finger;
+    }
+    if (priv->led_tapped) {
+        /* double-tapped? */
+        diff = TIME_DIFF(priv->led_tap_millis + para->tap_time_2, hw->millis);
+        if (diff >= 0) {
+            para->touchpad_off = !para->touchpad_off;
+            if (priv->proto_ops && priv->proto_ops->UpdateLED) {
+                para->led_status = para->touchpad_off;
+                priv->proto_ops->UpdateLED(pInfo);
+            }
+	    priv->prop_change_pending = 1;
+            priv->led_tapped = FALSE;
+        }
+    } else
+        priv->led_tapped = TRUE;
+    priv->led_tap_millis = hw->millis;
+    return 0; /* already processed; ignore this finger event */
+}
+
 /* clickpad event handling */
 static void
 handle_clickpad(InputInfoPtr pInfo, struct SynapticsHwState *hw)
@@ -1250,6 +1324,7 @@
 {
     InputInfoPtr pInfo = arg;
     SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    SynapticsParameters *para = &priv->synpara;
     struct SynapticsHwState hw;
     int delay;
     int sigstate;
@@ -1260,6 +1335,13 @@
     hw = priv->hwState;
     hw.millis = now;
     delay = HandleState(pInfo, &hw);
+    if (priv->prop_change_pending)
+	delay = MIN(10, delay);
+
+    if (priv->prop_change_pending) {
+	SynapticsToggleOffProperty(pInfo->dev, para->touchpad_off);
+	priv->prop_change_pending = 0;
+    }
 
     /*
      * Workaround for wraparound bug in the TimerSet function. This bug is already
@@ -2393,7 +2475,7 @@
     SynapticsParameters *para = &priv->synpara;
 
     /* Clickpad handling for button area */
-    if (priv->is_clickpad)
+    if (para->touchpad_off != 1 && priv->is_clickpad)
 	handle_clickpad(pInfo, hw);
 
     /* Treat the first two multi buttons as up/down for now. */
@@ -2511,7 +2593,7 @@
     update_shm(pInfo, hw);
 
     /* If touchpad is switched off, we skip the whole thing and return delay */
-    if (para->touchpad_off == 1)
+    if (para->touchpad_off == 1 && !(para->has_led && para->led_double_tap))
 	return delay;
 
     /* apply hysteresis before doing anything serious. This cancels
@@ -2555,6 +2637,15 @@
 	finger = SynapticsDetectFinger(priv, hw);
     }
 
+    if (para->has_led && para->led_double_tap) {
+	if (inside_active_area)
+		finger = handle_toggle_led(pInfo, hw, finger);
+        if (para->touchpad_off == 1) {
+            priv->finger_state = finger;
+            return delay;
+        }
+    }
+
     /* tap and drag detection. Needs to be performed even if the finger is in
      * the dead area to reset the state. */
     timeleft = HandleTapProcessing(priv, hw, finger, inside_active_area);
--- a/src/synapticsstr.h
+++ b/src/synapticsstr.h
@@ -167,6 +167,7 @@
     int hyst_x, hyst_y;                     /* x and y width of hysteresis box */
     Bool has_led;                           /* has an embedded LED */
     Bool led_status;                        /* Current status of LED (1=on) */
+    Bool led_double_tap;		    /* double-tap period in ms for touchpad LED control */
 } SynapticsParameters;
 
 
@@ -248,6 +249,11 @@
     Bool has_scrollbuttons;		/* device has physical scrollbuttons */
     Bool is_clickpad;			/* is Clickpad device (one-button) */
     struct SynapticsHwState prev_hw;	/* previous h/w state (for clickpad) */
+    int prop_change_pending;
+    Bool led_touch_state;
+    Bool led_tapped;
+    int led_touch_millis;
+    int led_tap_millis;
 
     enum TouchpadModel model;		/* The detected model */
     unsigned short id_vendor;		/* vendor id */
--- a/tools/synclient.c
+++ b/tools/synclient.c
@@ -143,6 +143,7 @@
     {"AreaTopEdge",           PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	2},
     {"AreaBottomEdge",        PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	3},
     {"LEDStatus",             PT_BOOL,   0, 1,     SYNAPTICS_PROP_LED_STATUS,	8,	0},
+    {"LEDDoubleTap",          PT_BOOL,   0, 1,     SYNAPTICS_PROP_LED_DOUBLE_TAP,	8,	0},
     { NULL, 0, 0, 0, 0 }
 };
 



#### xf86-input-synaptics-fix-clickpad-capabilities.diff
---
 src/eventcomm.c |   29 ++++++++++++++++++++++-------
 1 file changed, 22 insertions(+), 7 deletions(-)

--- a/src/eventcomm.c
+++ b/src/eventcomm.c
@@ -245,6 +245,25 @@
 
 
 static void
+event_query_clickpad(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
+
+    /* clickpad device reports only the single left button mask */
+    if (priv->has_left && !priv->has_right && !priv->has_middle &&
+	/*!priv->has_double &&*/
+	priv->model == MODEL_SYNAPTICS) {
+	priv->is_clickpad = TRUE;
+	/* enable right/middle button caps; otherwise gnome-settings-daemon
+	 * will ignore this device for left/right-hand setup because of a
+	 * single-button
+	 */
+	priv->has_right = priv->has_middle = TRUE;
+	xf86IDrvMsg(pInfo, X_INFO, "is Clickpad device\n");
+    }
+}
+
+static void
 event_query_led(InputInfoPtr pInfo)
 {
     SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
@@ -357,12 +376,6 @@
 	strcat(buf, " scroll-buttons");
 
     xf86IDrvMsg(pInfo, X_PROBED, "buttons:%s\n", buf);
-
-    /* clickpad device reports only the single left button mask */
-    if (priv->has_left && !priv->has_right && !priv->has_middle && !priv->has_double) {
-	priv->is_clickpad = TRUE;
-	xf86IDrvMsg(pInfo, X_PROBED, "is Clickpad device\n");
-    }
 }
 
 static Bool
@@ -536,11 +549,13 @@
 
     if (event_query_is_touchpad(pInfo->fd, (proto_data) ? proto_data->need_grab : TRUE))
 	event_query_axis_ranges(pInfo);
-    event_query_led(pInfo);
     event_query_model(pInfo->fd, &priv->model, &priv->id_vendor, &priv->id_product);
 
     xf86IDrvMsg(pInfo, X_PROBED, "Vendor %#hx Product %#hx\n",
                 priv->id_vendor, priv->id_product);
+
+    event_query_clickpad(pInfo);
+    event_query_led(pInfo);
 }
 
 static Bool



#### xf86-input-synaptics-clickpad-threshold.diff

---
 include/synaptics-properties.h |    6 +
 man/synaptics.man              |   30 ++++++-
 src/properties.c               |   15 +++
 src/synaptics.c                |  159 ++++++++++++++++++++++++++++++-----------
 src/synapticsstr.h             |    6 +
 tools/synclient.c              |    2 
 6 files changed, 172 insertions(+), 46 deletions(-)

--- a/include/synaptics-properties.h
+++ b/include/synaptics-properties.h
@@ -158,6 +158,12 @@
 /* 32 Bit Integer, 2 values, horizontal hysteresis, vertical hysteresis */
 #define SYNAPTICS_PROP_NOISE_CANCELLATION "Synaptics Noise Cancellation"
 
+/* 32bit */
+#define SYNAPTICS_PROP_TOUCH_BUTTON_AREA "Synaptics Touch Button Area"
+
+/* 32bit */
+#define SYNAPTICS_PROP_TOUCH_BUTTON_STICKY "Synapyics Touch Button Sticky"
+
 /* 8 bit (BOOL, read-only), has_led */
 #define SYNAPTICS_PROP_LED "Synaptics LED"
 
--- a/src/properties.c
+++ b/src/properties.c
@@ -94,6 +94,8 @@
 Atom prop_noise_cancellation    = 0;
 Atom prop_product_id            = 0;
 Atom prop_device_node           = 0;
+Atom prop_touch_button_area     = 0;
+Atom prop_touch_button_sticky   = 0;
 Atom prop_led                   = 0;
 Atom prop_led_status            = 0;
 Atom prop_led_double_tap        = 0;
@@ -299,6 +301,9 @@
     prop_noise_cancellation = InitAtom(pInfo->dev,
             SYNAPTICS_PROP_NOISE_CANCELLATION, 32, 2, values);
 
+    prop_touch_button_area = InitAtom(pInfo->dev, SYNAPTICS_PROP_TOUCH_BUTTON_AREA, 32, 1, &para->touch_button_area);
+    prop_touch_button_sticky = InitAtom(pInfo->dev, SYNAPTICS_PROP_TOUCH_BUTTON_STICKY, 32, 1, &para->touch_button_sticky);
+
     prop_led = InitAtom(pInfo->dev, SYNAPTICS_PROP_LED, 8, 1, &para->has_led);
     prop_led_status = InitAtom(pInfo->dev, SYNAPTICS_PROP_LED_STATUS, 8, 1, &para->led_status);
 
@@ -705,6 +710,16 @@
         para->area_right_edge  = area[1];
         para->area_top_edge    = area[2];
         para->area_bottom_edge = area[3];
+    } else if (property == prop_touch_button_area) {
+        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+	para->touch_button_area = *(INT32*)prop->data;
+    } else if (property == prop_touch_button_sticky) {
+        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+	para->touch_button_sticky = *(INT32*)prop->data;
     } else if (property == prop_led_status)
     {
         if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
--- a/src/synaptics.c
+++ b/src/synaptics.c
@@ -493,18 +493,6 @@
         vertResolution = priv->resy;
     }
 
-    /* Clickpad mode -- bottom area is used as buttons */
-    if (priv->is_clickpad) {
-	int button_bottom;
-	/* Clickpad devices usually the button area at the bottom, and
-	 * its size seems ca. 20% of the touchpad height no matter how
-	 * large the pad is.
-	 */
-	button_bottom = priv->maxy - (abs(priv->maxy - priv->miny) * 20) / 100;
-	if (button_bottom < b && button_bottom >= t)
-	    b = button_bottom;
-    }
-
     /* set the parameters */
     pars->left_edge = xf86SetIntOption(opts, "LeftEdge", l);
     pars->right_edge = xf86SetIntOption(opts, "RightEdge", r);
@@ -513,10 +501,6 @@
 
     pars->area_top_edge = set_percent_option(opts, "AreaTopEdge", height, priv->miny, 0);
     pars->area_bottom_edge = set_percent_option(opts, "AreaBottomEdge", height, priv->miny, 0);
-    /* in clickpad mode, we don't want to sense the button area as default */
-    if (pars->area_bottom_edge == 0 && priv->is_clickpad)
-	pars->area_bottom_edge = b;
-
     pars->area_left_edge = set_percent_option(opts, "AreaLeftEdge", width, priv->minx, 0);
     pars->area_right_edge = set_percent_option(opts, "AreaRightEdge", width, priv->minx, 0);
 
@@ -589,6 +573,8 @@
     pars->tap_and_drag_gesture = xf86SetBoolOption(opts, "TapAndDragGesture", TRUE);
     pars->resolution_horiz = xf86SetIntOption(opts, "HorizResolution", horizResolution);
     pars->resolution_vert = xf86SetIntOption(opts, "VertResolution", vertResolution);
+    pars->touch_button_area = xf86SetIntOption(opts, "TouchButtonArea", 20);
+    pars->touch_button_sticky = xf86SetIntOption(opts, "TouchButtonSticky", 64);
     pars->led_double_tap = xf86SetBoolOption(opts, "LEDDoubleTap", TRUE);
 
     /* Warn about (and fix) incorrectly configured TopEdge/BottomEdge parameters */
@@ -1096,6 +1082,11 @@
     return Success;
 }
 
+static void
+SetTapState(SynapticsPrivate *priv, enum TapState tap_state, int millis);
+static void
+SetMovingState(SynapticsPrivate *priv, enum MovingState moving_state, int millis);
+
 #define LED_TOGGLE_X_AREA	0.10
 #define LED_TOGGLE_Y_AREA	0.08
 
@@ -1164,45 +1155,119 @@
     return 0; /* already processed; ignore this finger event */
 }
 
+static void
+get_clickpad_button(SynapticsPrivate *priv, struct SynapticsHwState *hw,
+		    int button_x)
+{
+    int width = priv->maxx - priv->minx;
+    int left_button_x, right_button_x;
+
+    /* left and right clickpad button ranges;
+     * the gap between them is interpreted as a middle-button click
+     */
+    left_button_x = width * 2 / 5 + priv->minx;
+    right_button_x = width * 3 / 5 + priv->minx;
+
+    /* clickpad reports only one button, and we need
+     * to fake left/right buttons depending on the touch position
+     */
+    if (button_x < left_button_x)
+	hw->left = 1;
+    else if (button_x > right_button_x)
+	hw->right = 1;
+    else
+	hw->middle = 1;
+}
+
+static inline int get_touch_button_area(SynapticsPrivate *priv)
+{
+    SynapticsParameters *para = &priv->synpara;
+    return priv->maxy - (priv->maxy - priv->miny) * para->touch_button_area / 100;
+}
+
+#define is_main_bottom_edge(hw, priv) \
+    ((hw)->y >= get_touch_button_area(priv))
+
+static void reset_state_as_moving(SynapticsPrivate *priv, struct SynapticsHwState *hw)
+{
+    SynapticsParameters *para = &priv->synpara;
+
+    if (hw->z >= para->finger_low) {
+	SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
+	SetTapState(priv, TS_MOVE, hw->millis);
+	priv->touch_on.x = hw->x;
+	priv->touch_on.y = hw->y;
+	priv->touch_on.millis = hw->millis;
+    }
+    priv->tap_button = 0;
+}
+
 /* clickpad event handling */
 static void
 handle_clickpad(InputInfoPtr pInfo, struct SynapticsHwState *hw)
 {
     SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
     SynapticsParameters *para = &priv->synpara;
+    int in_main_button;
+
+    in_main_button = is_main_bottom_edge(hw, priv);
+    if (in_main_button) {
+	if (hw->left) {
+	    /* when button is pressed solely, don't move and ignore tapping */
+	    hw->z = 0;
+	    priv->count_packet_finger = 0;
+	    priv->ignore_tapping = TRUE;
+	    SetMovingState(priv, MS_FALSE, hw->millis);
+	    SetTapState(priv, TS_START, hw->millis);
+	    priv->tap_button = 0;
+	} else if (hw->z < para->finger_low) {
+	    priv->ignore_tapping = FALSE;
+	}
+    } else {
+	priv->ignore_tapping = FALSE;
+    }
 
     if (hw->left) { /* clicked? */
-	if (hw->y > para->bottom_edge) {
-	    /* button area */
-	    int width = priv->maxx - priv->minx;
-	    int left_button_x, right_button_x;
-
-	    /* left and right clickpad button ranges;
-	     * the gap between them is interpreted as a middle-button click
-	     */
-	    left_button_x = width * 2 / 5 + priv->minx;
-	    right_button_x = width * 3 / 5 + priv->minx;
-
-	    /* clickpad reports only one button, and we need
-	     * to fake left/right buttons depending on the touch position
-	     */
-	    hw->left = 0;
-	    if (hw->x < left_button_x)
-		hw->left = 1;
-	    else if (hw->x > right_button_x)
-		hw->right = 1;
-	    else
-		hw->middle = 1;
-	} else {
-	    /* dragging */
+	if (priv->clickpad_dragging) {
+	    /* already dragging, just copy the previous button state */
 	    hw->left = priv->prev_hw.left;
 	    hw->right = priv->prev_hw.right;
 	    hw->middle = priv->prev_hw.middle;
+	} else if (in_main_button) {
+	    /* start dragging */
+	    hw->left = 0;
+	    get_clickpad_button(priv, hw, hw->x);
+	    priv->clickpad_dragging = 1;
 	}
+    } else {
+	/* button being released, reset dragging if necessary */
+	if (priv->clickpad_dragging) {
+	    priv->count_packet_finger = 0;
+	    reset_state_as_moving(priv, hw);
+	}
+	hw->left = hw->right = hw->middle = 0;
+	priv->clickpad_dragging = 0;
+    }
+
+    if (in_main_button && para->touch_button_sticky > 0) {
+	if (!priv->count_packet_finger)  {
+	    /* if the primary track point is in the button area, be sticky */
+	    priv->clickpad_threshold = para->touch_button_sticky;
+	    priv->clickpad_dx = priv->clickpad_dy = 0;
+	}
+    } else {
+	/* outside the button area, clear stickiness */
+	priv->clickpad_threshold = 0;
     }
     priv->prev_hw = *hw;
 }
 
+static int
+move_distance(int dx, int dy)
+{
+    return sqrt(SQR(dx) + SQR(dy));
+}
+
 /*
  * Convert from absolute X/Y coordinates to a coordinate system where
  * -1 corresponds to the left/upper edge and +1 corresponds to the
@@ -1673,7 +1738,7 @@
     edge_type edge;
     int delay = 1000000000;
 
-    if (priv->palm)
+    if (priv->palm || priv->ignore_tapping)
 	return delay;
 
     touch = finger && !priv->finger_state;
@@ -2100,7 +2165,7 @@
 
     sd->left = sd->right = sd->up = sd->down = 0;
 
-    if (priv->synpara.touchpad_off == 2) {
+    if (priv->synpara.touchpad_off == 2 || priv->clickpad_dragging) {
 	stop_coasting(priv);
 	priv->circ_scroll_on = FALSE;
 	priv->vert_scroll_edge_on = FALSE;
@@ -2478,6 +2543,8 @@
     if (para->touchpad_off != 1 && priv->is_clickpad)
 	handle_clickpad(pInfo, hw);
 
+    priv->prev_hw = *hw;
+
     /* Treat the first two multi buttons as up/down for now. */
     hw->up |= hw->multi[0];
     hw->down |= hw->multi[1];
@@ -2671,6 +2738,14 @@
 
     if (!priv->absolute_events) {
       timeleft = ComputeDeltas(priv, hw, edge, &dx, &dy, inside_active_area);
+      if (priv->clickpad_threshold > 0) {
+	  priv->clickpad_dx += dx;
+	  priv->clickpad_dy += dy;
+	  if (move_distance(priv->clickpad_dx, priv->clickpad_dy) > priv->clickpad_threshold)
+	      priv->clickpad_threshold = 0;
+	  else
+	      dx = dy = 0;
+      }
       delay = MIN(delay, timeleft);
     }
 
@@ -2683,7 +2758,7 @@
 	       (hw->multi[2] ? 0x20 : 0) |
 	       (hw->multi[3] ? 0x40 : 0));
 
-    if (priv->tap_button > 0) {
+    if (priv->tap_button > 0 && !priv->ignore_tapping) {
 	int tap_mask = 1 << (priv->tap_button - 1);
 	if (priv->tap_button_state == TBS_BUTTON_DOWN_UP) {
 	    if (tap_mask != (priv->lastButtons & tap_mask)) {
--- a/src/synapticsstr.h
+++ b/src/synapticsstr.h
@@ -165,6 +165,8 @@
     unsigned int resolution_vert;           /* vertical resolution of touchpad in units/mm */
     int area_left_edge, area_right_edge, area_top_edge, area_bottom_edge; /* area coordinates absolute */
     int hyst_x, hyst_y;                     /* x and y width of hysteresis box */
+    int touch_button_area;                  /* clickpad button area */
+    int touch_button_sticky;                /* pointer stickiness in button area */
     Bool has_led;                           /* has an embedded LED */
     Bool led_status;                        /* Current status of LED (1=on) */
     Bool led_double_tap;		    /* double-tap period in ms for touchpad LED control */
@@ -248,6 +250,10 @@
     Bool has_width;			/* device reports finger width */
     Bool has_scrollbuttons;		/* device has physical scrollbuttons */
     Bool is_clickpad;			/* is Clickpad device (one-button) */
+    Bool ignore_tapping;
+    Bool clickpad_dragging;
+    unsigned int clickpad_threshold;
+    int clickpad_dx, clickpad_dy;
     struct SynapticsHwState prev_hw;	/* previous h/w state (for clickpad) */
     int prop_change_pending;
     Bool led_touch_state;
--- a/tools/synclient.c
+++ b/tools/synclient.c
@@ -142,6 +142,8 @@
     {"AreaRightEdge",         PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	1},
     {"AreaTopEdge",           PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	2},
     {"AreaBottomEdge",        PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	3},
+    {"TouchButtonArea",       PT_INT,    0, 100,   SYNAPTICS_PROP_TOUCH_BUTTON_AREA,	32,	0},
+    {"TouchButtonSticky",     PT_INT,    0, 1000,  SYNAPTICS_PROP_TOUCH_BUTTON_STICKY,	32,	0},
     {"LEDStatus",             PT_BOOL,   0, 1,     SYNAPTICS_PROP_LED_STATUS,	8,	0},
     {"LEDDoubleTap",          PT_BOOL,   0, 1,     SYNAPTICS_PROP_LED_DOUBLE_TAP,	8,	0},
     { NULL, 0, 0, 0, 0 }
--- a/man/synaptics.man
+++ b/man/synaptics.man
@@ -565,6 +565,21 @@
 "untouch" event happens when the Z value goes below FingerLow.
 .
 .TP
+.BI "Option \*qTouchButtonArea\*q \*q" integer \*q
+.
+Provides the size of the click-button area for ClickPad devices in
+percent. As default, it's 20.
+Property: "Synaptics Touch Button Area"
+.
+.TP
+.BI "Option \*qTouchButtonSticky\*q \*q" integer \*q
+.
+Provides the threshold to start moving in the click-button area.  The
+higher value is set, the pointer becomes sticky in the click-button
+area. The default value is 64.
+Property: "Synaptics Touch Button Sticky"
+.
+.TP
 .BI "Option \*qLEDDoubleTap\*q \*q" boolean \*q
 .
 Enables/disables the touchpad-control by double-tapping on the top-left
@@ -771,10 +786,9 @@
 and without multi-fingers, the driver assumes it's a Synaptics
 Clickpad device and handles it in ClickZone mode.  In this mode,
 a left/right/middle button event is generated according to the
-position you click.  When Clickpad is enabled, the touchpad area
-is shrunk as default in 20% and the bottom area is used as the
-click-button area.  The area can be configurable via options or
-properties below.
+position you click.  When Clickpad is enabled, the bottom area (as
+default 20%) is used as the click-button area.  The size of the area
+is configurable via options or properties below.
 
 .SH "DEVICE PROPERTIES"
 Synaptics 1.0 and higher support input device properties if the driver is
@@ -950,6 +964,14 @@
 32 bit unsigned, 2 values (read-only), vertical, horizontal in units/millimeter.
 
 .TP 7
+.BI "Synaptics Touch Button Area"
+32 bit.
+
+.TP 7
+.BI "Synaptics Touch Button Sticky"
+32 bit.
+
+.TP 7
 .BI "Synaptics LED"
 8 bit (BOOL, read-only), indicating whether the device has an embedded
 LED support or not.


#### xf86-input-synaptics-move-threshold.diff
---
 src/synaptics.c    |   11 +++++++++++
 src/synapticsstr.h |    1 +
 2 files changed, 12 insertions(+)

--- a/src/synaptics.c
+++ b/src/synaptics.c
@@ -441,6 +441,8 @@
     edgeMotionMaxSpeed = diag * .080;
     accelFactor = 200.0 / diag; /* trial-and-error */
 
+    priv->move_ptr_threshold = width / 5;
+
     /* hysteresis, assume >= 0 is a detected value (e.g. evdev fuzz) */
     horizHyst = pars->hyst_x >= 0 ? pars->hyst_x : diag * 0.005;
     vertHyst = pars->hyst_y >= 0 ? pars->hyst_y : diag * 0.005;
@@ -2042,6 +2044,15 @@
 	}
     }
 
+    if (moving_state && priv->count_packet_finger > 0 &&
+	priv->move_ptr_threshold > 0 ) {
+	int d = move_distance(HIST(0).x - hw->x, HIST(0).y - hw->y);
+	if (d > priv->move_ptr_threshold) {
+	    priv->count_packet_finger = 0; /* to avoid unexpected jumps */
+	    goto out;
+	}
+    }
+
     if (!inside_area || !moving_state || priv->palm ||
 	priv->vert_scroll_edge_on || priv->horiz_scroll_edge_on ||
 	priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on ||
--- a/src/synapticsstr.h
+++ b/src/synapticsstr.h
@@ -254,6 +254,7 @@
     unsigned int clickpad_threshold;
     int clickpad_dx, clickpad_dy;
     struct SynapticsHwState prev_hw;	/* previous h/w state (for clickpad) */
+    int move_ptr_threshold;
     int prop_change_pending;
     Bool led_touch_state;
     Bool led_tapped;



#### xf86-input-synaptics-filter-bogus-coord.diff
---
 src/eventcomm.c |   18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

--- a/src/eventcomm.c
+++ b/src/eventcomm.c
@@ -444,6 +444,21 @@
     struct SynapticsHwState *hw = &(comm->hwState);
     SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
     SynapticsParameters *para = &priv->synpara;
+    int minx, miny, maxx, maxy, x;
+
+    /* range to filger out; a bit wider range is allowed since some devices
+     * are too fuzzy and give slightly shifted positions
+     */
+    minx = priv->minx;
+    maxx = priv->maxx;
+    x = (maxx - minx) / 5;
+    minx -= (minx > x) ? x : minx;
+    maxx += x;
+    miny = priv->miny;
+    maxy = priv->maxy;
+    x = (maxy - miny) / 5;
+    maxy += miny;
+    miny -= (miny > x) ? x : miny;
 
     while (SynapticsReadEvent(pInfo, &ev)) {
 	switch (ev.type) {
@@ -451,6 +466,9 @@
 	    switch (ev.code) {
 	    case SYN_REPORT:
 		hw->numFingers = count_fingers(comm);
+		/* if the coord is out of range, we filter it out */
+		if (priv->is_clickpad && hw->z > 0 && (hw->x < minx || hw->x > maxx || hw->y < miny || hw->y > maxy))
+			return FALSE;
 		*hwRet = *hw;
 		return TRUE;
 	    }
