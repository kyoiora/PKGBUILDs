From ee4e3662aed011a987145247172efe0b006c700d Mon Sep 17 00:00:00 2001
Message-Id: <ee4e3662aed011a987145247172efe0b006c700d.1335998213.git.matthew.monaco@0x01b.net>
From: Takashi Iwai <tiwai@suse.de>
Date: Mon, 10 May 2010 18:15:48 +0200
Subject: [PATCH 1/2] Add the embedded LED support

This patch adds the control of the embedded LED on the top-left corner
of new Synaptics devices.  For LED control, it requires the patch to
Linux synaptics input driver,
	https://patchwork.kernel.org/patch/92434/

When a sysfs file /sys/class/leds/psmouse::synaptics exists, the driver
assumes it supports the embeded LED control.

The LED can be controlled via new properties, "Synaptics LED" and
"Synaptics LED Status".

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 include/synaptics-properties.h |    6 ++++++
 man/synaptics.man              |    9 +++++++++
 src/eventcomm.c                |   32 +++++++++++++++++++++++++++++++-
 src/properties.c               |   15 +++++++++++++++
 src/synapticsstr.h             |    2 ++
 src/synproto.h                 |    1 +
 tools/synclient.c              |    1 +
 7 files changed, 65 insertions(+), 1 deletion(-)

diff --git a/include/synaptics-properties.h b/include/synaptics-properties.h
index 8c20a0c..4689a4d 100644
--- a/include/synaptics-properties.h
+++ b/include/synaptics-properties.h
@@ -164,4 +164,10 @@
 /* 32 Bit Integer, 2 values, horizontal hysteresis, vertical hysteresis */
 #define SYNAPTICS_PROP_NOISE_CANCELLATION "Synaptics Noise Cancellation"
 
+/* 8 bit (BOOL, read-only), has_led */
+#define SYNAPTICS_PROP_LED "Synaptics LED"
+
+/* 8 bit (BOOL), led_status (on/off) */
+#define SYNAPTICS_PROP_LED_STATUS "Synaptics LED Status"
+
 #endif /* _SYNAPTICS_PROPERTIES_H_ */
diff --git a/man/synaptics.man b/man/synaptics.man
index ab6e61d..cb6c8c4 100644
--- a/man/synaptics.man
+++ b/man/synaptics.man
@@ -979,6 +979,15 @@ right button, two-finger detection, three-finger detection, pressure detection,
 .BI "Synaptics Pad Resolution"
 32 bit unsigned, 2 values (read-only), vertical, horizontal in units/millimeter.
 
+.TP 7
+.BI "Synaptics LED"
+8 bit (BOOL, read-only), indicating whether the device has an embedded
+LED support or not.
+
+.TP 7
+.BI "Synaptics LED Status"
+8 bit (BOOL), the light status of the embedded LED.
+
 .SH "NOTES"
 Configuration through
 .I InputClass
diff --git a/src/eventcomm.c b/src/eventcomm.c
index 4ef8ad6..926605d 100644
--- a/src/eventcomm.c
+++ b/src/eventcomm.c
@@ -60,6 +60,8 @@
 #define LONG(x)  ((x) / LONG_BITS)
 #define TEST_BIT(bit, array) ((array[LONG(bit)] >> OFF(bit)) & 1)
 
+#define SYNAPTICS_LED_SYS_FILE	"/sys/class/leds/psmouse::synaptics/brightness"
+
 /**
  * Protocol-specific data.
  */
@@ -379,6 +381,32 @@ event_get_abs(InputInfoPtr pInfo, int fd, int code,
 }
 
 
+static void
+event_query_led(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
+
+    priv->synpara.has_led = !access(SYNAPTICS_LED_SYS_FILE, W_OK);
+}
+
+static void EventUpdateLED(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
+
+    if (priv->synpara.has_led) {
+        char *val = priv->synpara.led_status ? "255" : "0";
+        int fd = open(SYNAPTICS_LED_SYS_FILE, O_WRONLY);
+        int err;
+
+        if (fd < 0)
+            return;
+        err = write(fd, val, strlen(val));
+        close(fd);
+        if (err < 0)
+	    xf86IDrvMsg(pInfo, X_WARNING, "can't write LED value %s\n", val);
+    }
+}
+
 /* Query device for axis ranges */
 static void
 event_query_axis_ranges(InputInfoPtr pInfo)
@@ -929,6 +957,7 @@ EventReadDevDimensions(InputInfoPtr pInfo)
 #endif
         event_query_axis_ranges(pInfo);
     }
+    event_query_led(pInfo);
     event_query_model(pInfo->fd, &priv->model, &priv->id_vendor, &priv->id_product);
 
     xf86IDrvMsg(pInfo, X_PROBED, "Vendor %#hx Product %#hx\n",
@@ -1009,5 +1038,6 @@ struct SynapticsProtocolOperations event_proto_operations = {
     EventQueryHardware,
     EventReadHwState,
     EventAutoDevProbe,
-    EventReadDevDimensions
+    EventReadDevDimensions,
+    EventUpdateLED,
 };
diff --git a/src/properties.c b/src/properties.c
index 783b516..944f229 100644
--- a/src/properties.c
+++ b/src/properties.c
@@ -96,6 +96,8 @@ Atom prop_softbutton_areas      = 0;
 Atom prop_noise_cancellation    = 0;
 Atom prop_product_id            = 0;
 Atom prop_device_node           = 0;
+Atom prop_led                   = 0;
+Atom prop_led_status            = 0;
 
 static Atom
 InitTypedAtom(DeviceIntPtr dev, char *name, Atom type, int format, int nvalues,
@@ -327,6 +329,9 @@ InitDeviceProperties(InputInfoPtr pInfo)
     prop_noise_cancellation = InitAtom(pInfo->dev,
             SYNAPTICS_PROP_NOISE_CANCELLATION, 32, 2, values);
 
+    prop_led = InitAtom(pInfo->dev, SYNAPTICS_PROP_LED, 8, 1, &para->has_led);
+    prop_led_status = InitAtom(pInfo->dev, SYNAPTICS_PROP_LED_STATUS, 8, 1, &para->led_status);
+
     /* only init product_id property if we actually know them */
     if (priv->id_vendor || priv->id_product)
     {
@@ -757,6 +762,16 @@ SetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
 
         memcpy(para->softbutton_areas[0], areas, 4 * sizeof(int));
         memcpy(para->softbutton_areas[1], areas + 4, 4 * sizeof(int));
+    } else if (property == prop_led_status)
+    {
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        if (para->has_led) {
+            para->led_status = *(BOOL*)prop->data;
+            if (priv->proto_ops && priv->proto_ops->UpdateLED)
+                priv->proto_ops->UpdateLED(pInfo);
+        }
     } else if (property == prop_noise_cancellation) {
         INT32 *hyst;
         if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
diff --git a/src/synapticsstr.h b/src/synapticsstr.h
index 14ae362..51b89f7 100644
--- a/src/synapticsstr.h
+++ b/src/synapticsstr.h
@@ -184,6 +184,8 @@ typedef struct _SynapticsParameters
     int area_left_edge, area_right_edge, area_top_edge, area_bottom_edge; /* area coordinates absolute */
     int softbutton_areas[2][4];             /* soft button area coordinates, 0 => right, 1 => middle button */
     int hyst_x, hyst_y;                     /* x and y width of hysteresis box */
+    Bool has_led;                           /* has an embedded LED */
+    Bool led_status;                        /* Current status of LED (1=on) */
 } SynapticsParameters;
 
 
diff --git a/src/synproto.h b/src/synproto.h
index 413579d..0837fa8 100644
--- a/src/synproto.h
+++ b/src/synproto.h
@@ -102,6 +102,7 @@ struct SynapticsProtocolOperations {
 			struct CommData *comm, struct SynapticsHwState *hwRet);
     Bool (*AutoDevProbe)(InputInfoPtr pInfo, const char *device);
     void (*ReadDevDimensions)(InputInfoPtr pInfo);
+    void (*UpdateLED)(InputInfoPtr pInfo);
 };
 
 #ifdef BUILD_PS2COMM
diff --git a/tools/synclient.c b/tools/synclient.c
index 6c8ee7a..94b9ade 100644
--- a/tools/synclient.c
+++ b/tools/synclient.c
@@ -154,6 +154,7 @@ static struct Parameter params[] = {
     {"MiddleButtonAreaRight", PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	5},
     {"MiddleButtonAreaTop",   PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	6},
     {"MiddleButtonAreaBottom", PT_INT, INT_MIN, INT_MAX, SYNAPTICS_PROP_SOFTBUTTON_AREAS,	32,	7},
+    {"LEDStatus",             PT_BOOL,   0, 1,     SYNAPTICS_PROP_LED_STATUS,	8,	0},
     { NULL, 0, 0, 0, 0 }
 };
 
-- 
1.7.10.1

